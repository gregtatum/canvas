import * as Quads from "../";
import { assertArt, replaceCodepoint } from "./helpers";

describe("QuadMesh", () => {
  it("can create a quad from positions", () => {
    const { mesh } = Quads.createQuad({
      positions: [
        [-4.0, 0.0, -3.0],
        [-4.0, 0.0, 3.0],
        [1.0, 0.0, 3.0],
        [1.0, 0.0, -3.0],
      ],
    });

    assertArt(
      mesh,
      "y",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -3  ·  ◆━━━━━━━━━━━━━━◆  ·  ·  ·  ·
      │ -2  ·  ┃  ·  ·  ·  ┊  ┃  ·  ·  ·  ·
      │ -1  ·  ┃  ·  ·  ·  ┊  ┃  ·  ·  ·  ·
      │  0 ┈┈┈┈┃┈┈┈┈┈┈┈┈┈┈┈┊┈┈┃┈┈┈┈┈┈┈┈┈┈┈┈┈
      │  1  ·  ┃  ·  ·  ·  ┊  ┃  ·  ·  ·  ·
      │  2  ·  ┃  ·  ·  ·  ┊  ┃  ·  ·  ·  ·
      │  3  ·  ◆━━━━━━━━━━━━━━◆  ·  ·  ·  ·
      │  4  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );
  });

  it("can create a quad from size", () => {
    const { mesh } = Quads.createQuad({ w: 2, h: 4, facing: "z+" });

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -3  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -2  ·  ·  ·  ·  ◆━━━━━◆  ·  ·  ·  ·
      │ -1  ·  ·  ·  ·  ┃  ┊  ┃  ·  ·  ·  ·
      │  0 ┈┈┈┈┈┈┈┈┈┈┈┈┈┃┈┈┊┈┈┃┈┈┈┈┈┈┈┈┈┈┈┈┈
      │  1  ·  ·  ·  ·  ┃  ┊  ┃  ·  ·  ·  ·
      │  2  ·  ·  ·  ·  ◆━━━━━◆  ·  ·  ·  ·
      │  3  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │  4  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );
  });

  it("can split a quad vertically", () => {
    const { mesh } = Quads.createQuad({ w: 8, h: 8, facing: "z+" });

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │ -3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  0 ┈┈┈┈┃┈┈┈┈┈┈┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈
      │  1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );

    Quads.splitVertical(mesh, mesh.quads[0], 0.25);
    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ◆━━━━━◆━━━━━━━━━━━━━━━━━◆  ·
      │ -3  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │ -2  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │ -1  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │  0 ┈┈┈┈┃┈┈┈┈┈┃┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈
      │  1  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │  2  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │  3  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │  4  ·  ◆━━━━━◆━━━━━━━━━━━━━━━━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );
  });

  it("can split a quad horizontally", () => {
    const { mesh } = Quads.createQuad({ w: 8, h: 8, facing: "z+" });

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │ -3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  0 ┈┈┈┈┃┈┈┈┈┈┈┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈
      │  1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );

    Quads.splitHorizontal(mesh, mesh.quads[0], 0.25);
    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │ -3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  0 ┈┈┈┈┃┈┈┈┈┈┈┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈
      │  1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  2  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │  3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );
  });

  it("can split a quad horizontally disjointly", () => {
    const { mesh } = Quads.createQuad({ w: 8, h: 8, facing: "z+" });

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │ -3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  0 ┈┈┈┈┃┈┈┈┈┈┈┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈
      │  1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );

    Quads.splitHorizontalDisjoint(mesh, mesh.quads[0], 0.25);
    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │ -3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -2  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │ -1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  0 ┈┈┈┈┃┈┈┈┈┈┈┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈
      │  1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );
  });

  it("can split a quad horizontally disjointly", () => {
    const { mesh } = Quads.createQuad({ w: 8, h: 8, facing: "z+" });

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │ -3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │ -1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  0 ┈┈┈┈┃┈┈┈┈┈┈┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈
      │  1  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  2  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  3  ·  ┃  ·  ·  ·  ┊  ·  ·  ·  ┃  ·
      │  4  ·  ◆━━━━━━━━━━━━━━━━━━━━━━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );

    Quads.splitVerticalDisjoint(mesh, mesh.quads[0], 0.25);
    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ◆━━━━━◆━━━━━━━━━━━━━━━━━◆  ·
      │ -3  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │ -2  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │ -1  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │  0 ┈┈┈┈┃┈┈┈┈┈┃┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈
      │  1  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │  2  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │  3  ·  ┃  ·  ┃  ·  ┊  ·  ·  ·  ┃  ·
      │  4  ·  ◆━━━━━◆━━━━━━━━━━━━━━━━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );

    for (const p of Quads.getPositions(mesh, mesh.quads[1])) {
      p[0] += 1;
      p[1] += 1;
    }
    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ◆━━━━━◆  ·  ┊  ·  ·  ·  ·  ·
      │ -3  ·  ┃  ·  ┃  ◆━━━━━━━━━━━━━━━━━◆
      │ -2  ·  ┃  ·  ┃  ┃  ┊  ·  ·  ·  ·  ┃
      │ -1  ·  ┃  ·  ┃  ┃  ┊  ·  ·  ·  ·  ┃
      │  0 ┈┈┈┈┃┈┈┈┈┈┃┈┈┃┈┈┊┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃┈
      │  1  ·  ┃  ·  ┃  ┃  ┊  ·  ·  ·  ·  ┃
      │  2  ·  ┃  ·  ┃  ┃  ┊  ·  ·  ·  ·  ┃
      │  3  ·  ┃  ·  ┃  ┃  ┊  ·  ·  ·  ·  ┃
      │  4  ·  ◆━━━━━◆  ┃  ┊  ·  ·  ·  ·  ┃
      │  5  ·  ·  ·  ·  ◆━━━━━━━━━━━━━━━━━◆
      `
    );
  });

  it("can clone a quad", () => {
    const { mesh } = Quads.createQuad({ w: 4, h: 4, facing: "z+" });

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -3  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -2  ·  ·  ·  ◆━━━━━━━━━━━◆  ·  ·  ·
      │ -1  ·  ·  ·  ┃  ·  ┊  ·  ┃  ·  ·  ·
      │  0 ┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈┈┊┈┈┈┈┈┃┈┈┈┈┈┈┈┈┈┈
      │  1  ·  ·  ·  ┃  ·  ┊  ·  ┃  ·  ·  ·
      │  2  ·  ·  ·  ◆━━━━━━━━━━━◆  ·  ·  ·
      │  3  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │  4  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );

    Quads.clone(mesh, mesh.quads[0]);
    for (const p of Quads.getPositions(mesh, mesh.quads[0])) {
      p[0] += 2;
      p[1] += 2;
    }
    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -3  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -2  ·  ·  ·  ◆━━━━━━━━━━━◆  ·  ·  ·
      │ -1  ·  ·  ·  ┃  ·  ┊  ·  ┃  ·  ·  ·
      │  0 ┈┈┈┈┈┈┈┈┈┈┃┈┈┈┈┈◆━━━━━┃━━━━━◆┈┈┈┈
      │  1  ·  ·  ·  ┃  ·  ┃  ·  ┃  ·  ┃  ·
      │  2  ·  ·  ·  ◆━━━━━━━━━━━◆  ·  ┃  ·
      │  3  ·  ·  ·  ·  ·  ┃  ·  ·  ·  ┃  ·
      │  4  ·  ·  ·  ·  ·  ◆━━━━━━━━━━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );
  });

  it("can render diagonals (-x, -y)", () => {
    const { mesh } = Quads.createQuad({ w: 4, h: 4, facing: "z+" });
    for (const p of Quads.getPositions(mesh, 0)) {
      p[0] += 3;
      p[1] += 3;
    }
    mesh.positions[0][0] -= 5;
    mesh.positions[0][1] -= 5;

    assertArt(
      mesh,
      "z",
      `
        │    -5 -4 -3 -2 -1  0  1  2  3  4  5
        │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
        │ -4  ·  ◆━━·  ·  ·  ┊  ·  ·  ·  ·  ·
        │ -3  ·  · ⟍━━━━━━·  ┊  ·  ·  ·  ·  ·
        │ -2  ·  ·  ⟍  ·  ━━━━━ ·  ·  ·  ·  ·
        │ -1  ·  ·  · ⟍·  ·  ┊ ━━━━━  ·  ·  ·
        │  0 ┈┈┈┈┈┈┈┈┈┈┈⟍┈┈┈┈┊┈┈┈┈┈┈━━━━━━┈┈┈┈
        │  1  ·  ·  ·  · ⟍·  ┊  ·  ·  ·  ·━━◆
        │  2  ·  ·  ·  ·  ·⟍ ┊  ·  ·  ·  ·  ┃
        │  3  ·  ·  ·  ·  ·  ⟍  ·  ·  ·  ·  ┃
        │  4  ·  ·  ·  ·  ·  ┊⟍ ·  ·  ·  ·  ┃
        │  5  ·  ·  ·  ·  ·  ┊  ◆━━━━━━━━━━━◆
        `
    );
  });

  it("can render diagonals (+x, -y)", () => {
    const { mesh } = Quads.createQuad({ w: 4, h: 4, facing: "z+" });
    for (const p of Quads.getPositions(mesh, 0)) {
      p[0] -= 3;
      p[1] += 3;
    }
    mesh.positions[3][0] += 5;
    mesh.positions[3][1] -= 5;

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      │ -4  ·  ·  ·  ·  ·  ┊  ·  ·  ·━━◆  ·
      │ -3  ·  ·  ·  ·  ·  ┊  ·━━━━━━⟋ ·  ·
      │ -2  ·  ·  ·  ·  · ━━━━━  ·  ⟋  ·  ·
      │ -1  ·  ·  ·  ━━━━━ ┊  ·  ·⟋ ·  ·  ·
      │  0 ┈┈┈┈━━━━━━┈┈┈┈┈┈┊┈┈┈┈⟋┈┈┈┈┈┈┈┈┈┈┈
      │  1  ◆━━·  ·  ·  ·  ┊  ·⟋ ·  ·  ·  ·
      │  2  ┃  ·  ·  ·  ·  ┊ ⟋·  ·  ·  ·  ·
      │  3  ┃  ·  ·  ·  ·  ⟋  ·  ·  ·  ·  ·
      │  4  ┃  ·  ·  ·  · ⟋┊  ·  ·  ·  ·  ·
      │  5  ◆━━━━━━━━━━━◆  ┊  ·  ·  ·  ·  ·
      `
    );
  });

  it("can render diagonals (-x, +y)", () => {
    const { mesh } = Quads.createQuad({ w: 4, h: 4, facing: "z+" });
    for (const p of Quads.getPositions(mesh, 0)) {
      p[0] += 3;
      p[1] -= 3;
    }
    mesh.positions[1][0] -= 5;
    mesh.positions[1][1] += 5;

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  ·  ┊  ◆━━━━━━━━━━━◆
      │ -4  ·  ·  ·  ·  ·  ┊⟋ ·  ·  ·  ·  ┃
      │ -3  ·  ·  ·  ·  ·  ⟋  ·  ·  ·  ·  ┃
      │ -2  ·  ·  ·  ·  ·⟋ ┊  ·  ·  ·  ·  ┃
      │ -1  ·  ·  ·  · ⟋·  ┊  ·  ·  ·  ·━━◆
      │  0 ┈┈┈┈┈┈┈┈┈┈┈⟋┈┈┈┈┊┈┈┈┈┈┈━━━━━━┈┈┈┈
      │  1  ·  ·  · ⟋·  ·  ┊ ━━━━━  ·  ·  ·
      │  2  ·  ·  ⟋  ·  ━━━━━ ·  ·  ·  ·  ·
      │  3  ·  · ⟋━━━━━━·  ┊  ·  ·  ·  ·  ·
      │  4  ·  ◆━━·  ·  ·  ┊  ·  ·  ·  ·  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );
  });

  it("can render diagonals (+x, +y)", () => {
    const { mesh } = Quads.createQuad({ w: 4, h: 4, facing: "z+" });
    for (const p of Quads.getPositions(mesh, 0)) {
      p[0] -= 3;
      p[1] -= 3;
    }
    mesh.positions[2][0] += 5;
    mesh.positions[2][1] += 5;

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ◆━━━━━━━━━━━◆  ┊  ·  ·  ·  ·  ·
      │ -4  ┃  ·  ·  ·  · ⟍┊  ·  ·  ·  ·  ·
      │ -3  ┃  ·  ·  ·  ·  ⟍  ·  ·  ·  ·  ·
      │ -2  ┃  ·  ·  ·  ·  ┊ ⟍·  ·  ·  ·  ·
      │ -1  ◆━━·  ·  ·  ·  ┊  ·⟍ ·  ·  ·  ·
      │  0 ┈┈┈┈━━━━━━┈┈┈┈┈┈┊┈┈┈┈⟍┈┈┈┈┈┈┈┈┈┈┈
      │  1  ·  ·  ·  ━━━━━ ┊  ·  ·⟍ ·  ·  ·
      │  2  ·  ·  ·  ·  · ━━━━━  ·  ⟍  ·  ·
      │  3  ·  ·  ·  ·  ·  ┊  ·━━━━━━⟍ ·  ·
      │  4  ·  ·  ·  ·  ·  ┊  ·  ·  ·━━◆  ·
      │  5  ·  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ·
      `
    );
  });

  it("insets geometry", () => {
    const { mesh } = Quads.createQuad({ w: 10, h: 10, facing: "z+" });

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      │ -4  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │ -3  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │ -2  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │ -1  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  0 ┈┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃┈
      │  1  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  2  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  3  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  4  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      `
    );

    Quads.inset(mesh, mesh.quads[0], 0.55);

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      │ -4  ┃ ━━━ ·  ·  ·  ┊  ·  ·  · ━━━ ┃
      │ -3  ┃  · ━━━ ·  ·  ┊  ·  · ━━━ ·  ┃
      │ -2  ┃  ·  · ◆━━━━━━━━━━━━━◆ ·  ·  ┃
      │ -1  ┃  ·  · ┃·  ·  ┊  ·  ·┃ ·  ·  ┃
      │  0 ┈┃┈┈┈┈┈┈┈┃┈┈┈┈┈┈┊┈┈┈┈┈┈┃┈┈┈┈┈┈┈┃┈
      │  1  ┃  ·  · ┃·  ·  ┊  ·  ·┃ ·  ·  ┃
      │  2  ┃  ·  · ◆━━━━━━━━━━━━━◆ ·  ·  ┃
      │  3  ┃  · ━━━ ·  ·  ┊  ·  · ━━━ ·  ┃
      │  4  ┃ ━━━ ·  ·  ·  ┊  ·  ·  · ━━━ ┃
      │  5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      `
    );
  });

  it("insets geometry disjointly", () => {
    const { mesh } = Quads.createQuad({ w: 10, h: 10, facing: "z+" });

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      │ -4  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │ -3  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │ -2  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │ -1  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  0 ┈┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃┈
      │  1  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  2  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  3  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  4  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      `
    );

    Quads.insetDisjoint(mesh, mesh.quads[0], 0.55);

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      │ -4  ┃ ━━━ ·  ·  ·  ┊  ·  ·  · ━━━ ┃
      │ -3  ┃  · ━━━ ·  ·  ┊  ·  · ━━━ ·  ┃
      │ -2  ┃  ·  · ◆━━━━━━━━━━━━━◆ ·  ·  ┃
      │ -1  ┃  ·  · ┃·  ·  ┊  ·  ·┃ ·  ·  ┃
      │  0 ┈┃┈┈┈┈┈┈┈┃┈┈┈┈┈┈┊┈┈┈┈┈┈┃┈┈┈┈┈┈┈┃┈
      │  1  ┃  ·  · ┃·  ·  ┊  ·  ·┃ ·  ·  ┃
      │  2  ┃  ·  · ◆━━━━━━━━━━━━━◆ ·  ·  ┃
      │  3  ┃  · ━━━ ·  ·  ┊  ·  · ━━━ ·  ┃
      │  4  ┃ ━━━ ·  ·  ·  ┊  ·  ·  · ━━━ ┃
      │  5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      `
    );

    for (const p of Quads.getPositions(mesh, 0)) {
      p[0] += 2;
      p[1] += 2;
    }

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      │ -4  ┃ ━━━ ·  ·  ·  ┊  ·  ·  · ━━━ ┃
      │ -3  ┃  · ━━━ ·  ·  ┊  ·  · ━━━ ·  ┃
      │ -2  ┃  ·  · ◆━━━━━━━━━━━━━◆ ·  ·  ┃
      │ -1  ┃  ·  · ┃·  ·  ┊  ·  ·┃ ·  ·  ┃
      │  0 ┈┃┈┈┈┈┈┈┈┃┈┈┈┈┈◆━━━━━━━┃━━━━━◆┈┃┈
      │  1  ┃  ·  · ┃·  · ┃┊  ·  ·┃ ·  ·┃ ┃
      │  2  ┃  ·  · ◆━━━━━━━━━━━━━◆ ·  ·┃ ┃
      │  3  ┃  · ━━━ ·  · ┃┊  ·  · ━━━ ·┃ ┃
      │  4  ┃ ━━━ ·  ·  · ◆━━━━━━━━━━━━━◆ ┃
      │  5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      `
    );
  });

  it("extrudes geometry", () => {
    const { mesh } = Quads.createQuad({ w: 10, h: 10, facing: "z+" });

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      │ -4  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │ -3  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │ -2  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │ -1  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  0 ┈┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┊┈┈┈┈┈┈┈┈┈┈┈┈┈┈┃┈
      │  1  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  2  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  3  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  4  ┃  ·  ·  ·  ·  ┊  ·  ·  ·  ·  ┃
      │  5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      `
    );

    Quads.extrude(mesh, mesh.quads[0], 0.55, 1);

    assertArt(
      mesh,
      "z",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      │ -4  ┃ ━━━ ·  ·  ·  ┊  ·  ·  · ━━━ ┃
      │ -3  ┃  · ━━━ ·  ·  ┊  ·  · ━━━ ·  ┃
      │ -2  ┃  ·  · ◆━━━━━━━━━━━━━◆ ·  ·  ┃
      │ -1  ┃  ·  · ┃·  ·  ┊  ·  ·┃ ·  ·  ┃
      │  0 ┈┃┈┈┈┈┈┈┈┃┈┈┈┈┈┈┊┈┈┈┈┈┈┃┈┈┈┈┈┈┈┃┈
      │  1  ┃  ·  · ┃·  ·  ┊  ·  ·┃ ·  ·  ┃
      │  2  ┃  ·  · ◆━━━━━━━━━━━━━◆ ·  ·  ┃
      │  3  ┃  · ━━━ ·  ·  ┊  ·  · ━━━ ·  ┃
      │  4  ┃ ━━━ ·  ·  ·  ┊  ·  ·  · ━━━ ┃
      │  5  ◆━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◆
      `
    );

    assertArt(
      mesh,
      "x",
      `
      │    -5 -4 -3 -2 -1  0  1  2  3  4  5
      │ -5  ·  ·  ·  ·  · ━◆  ·  ·  ·  ·  ·
      │ -4  ·  ·  ·  · ━━━ ┃  ·  ·  ·  ·  ·
      │ -3  ·  ·  ·━━━━ ·  ┃  ·  ·  ·  ·  ·
      │ -2  ·  ·  ◆  ·  ·  ┃  ·  ·  ·  ·  ·
      │ -1  ·  ·  ┃  ·  ·  ┃  ·  ·  ·  ·  ·
      │  0 ┈┈┈┈┈┈┈┃┈┈┈┈┈┈┈┈┃┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
      │  1  ·  ·  ┃  ·  ·  ┃  ·  ·  ·  ·  ·
      │  2  ·  ·  ◆  ·  ·  ┃  ·  ·  ·  ·  ·
      │  3  ·  ·  ·━━━━ ·  ┃  ·  ·  ·  ·  ·
      │  4  ·  ·  ·  · ━━━ ┃  ·  ·  ·  ·  ·
      │  5  ·  ·  ·  ·  · ━◆  ·  ·  ·  ·  ·
      `
    );
  });
});

describe("replaceCodepoint", () => {
  it("replaces text from the basic multilingual plane", () => {
    const alphabet = "abcdefghijklmnopqrstuvwxyz";
    expect(replaceCodepoint(alphabet, "_", 3)).toEqual(
      "abc_efghijklmnopqrstuvwxyz"
    );
    expect(replaceCodepoint(alphabet, "👍", 3)).toEqual(
      "abc👍efghijklmnopqrstuvwxyz"
    );
  });

  it("replaces text from higher planes", () => {
    const phrase = "Yes 👍 sounds good";
    expect(phrase.length).toEqual(18);
    expect([...phrase].length).toEqual(17);
    expect(replaceCodepoint(phrase, "_", 6)).toEqual("Yes 👍 _ounds good");
  });
});
